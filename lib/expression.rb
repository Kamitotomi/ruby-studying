#正規表現を使って条件に当てはまる単語を抜き出してみる

I like Ruby.
Python is great language.
Java and JavaScript are different.

#上の文章からプログラミング言語を抜き出す
text = <<TEXT

I like Ruby.
Python is great language.
Java and JavaScript are different.
TEXT

text.scan(/[A-Z][A-Za-z]+/)

#文字列の返還

text = <<TEXT
私の郵便番号は1234567です。
俺の住所は6770056 兵庫県西脇市板波町1234だぜ。
TEXT

puts text.gsub(/(\d{3})(\d{4})/, '\1-\2')

#\dは　1個の半角数字の意味である \d\dなら半角数字2個 \dみたいなのは「メタ文字」と呼ぶ

#この場合はどうする？
text = <<TEXT
名前：伊藤淳一
電話：03-1234-5678
電話：090-1234-5678
電話：0795-12-3456
電話：04992-1-2345
住所：兵庫県西脇市板波町1-2-3
TEXT

#まずは法則を見つける。上の場合は「半角数字が2個～5個、ハイフン、半角数字が1個～4個、ハイフン、半角数字が4個」

#量産指定子{n,m} や {n} というメタ文字。{n,m} は「直前の文字が n 個以上、m 個以下」の意味

puts text.gsub(\d{2,5}-\d{1,4}-\d{4})

text = <<-TEXT
名前：伊藤淳一
電話：03(1234)5678
？？：9999-99-9999
？？：03(1234-5678
住所：兵庫県西脇市板波町1-2-3
TEXT
numbers = text.scan(/0[1-9]\d{0,3}[-(]\d{1,4}[-)]\d{4}/)

numbers.grep(/\(\d+\)|-\d+-/)

#重要なこと

\d は「半角数字1文字」を表す
{n,m} は「直前の文字が n 文字以上、m 文字以下」であることを表す
{n} は「直前の文字がちょうど n 文字」であることを表す
[AB] は「AまたはBが1文字」であることを表す
[a-z] と [-az] ではハイフンの意味が異なる
正規表現の正確さと複雑さはトレードオフになることが多い


text = <<-TEXT
クープバゲットのパンは美味しかった。
今日はクープ バゲットさんに行きました。
クープ　バゲットのパンは最高。
ジャムおじさんのパン、ジャムが入ってた。
また行きたいです。クープ・バゲット。
クープ・バケットのパン、売り切れだった（><）
TEXT

text.split(/\n/).grep(/クープ.?バ[ゲケ]ット/)



text = '私の誕生日は1999年6月21日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)

m[0]
m[1]
m[2]
m[3]
#キャプチャの2番目から2個取得の意味
m[2,2]
m[-1]
m[1..3]



#条件分岐の中で真偽値の判定とローカル変数への代入を同時に行う

text = '私の誕生日は1999年6月21日です。'

if m = /(\d+)年(\d+)月(\d+)日/.match(text)
	puts '合ったぜ'
else
	puts '合わなかったぜ'
end

#キャプチャの結果に名前をつける

text = '私の誕生日は2000年3月8日です'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)


m[:year]
m[:month]
m[:day]
#文字列での指定
m['year']
#連番での指定
m[2]

text = '私の誕生日は2000年3月8日です'

if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
	puts "#{year}/#{month}/#{day}"
end

#scan => 引数で渡した正規表現にマッチする部分を配列に

'123 456 789'.scan(/\d+/)

#マッチした文字列全体を取得
　'2018年12月26日'.scan(/\d+年\d+月\d+日/)

#[]に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出す(最初にマッチしたものから抜き出す)
text = '郵便番号は555-5555 111-1111'
text[/\d{3}-\d{4}/]

#名前付きキャプチャは指定して呼び出すことが可能

text = '私の誕生日は2000年3月8日です'
#シンボルで指定
text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, :year]

#slice
text = '郵便番号は555-5555です'
text.slice(/\d{3}-\d{4}/)

text = '私の誕生日は2000年3月8日です'
text.slice(/(\d+)年(\d+)月(\d+)日/, 3)
#3は何番目の数字を抜き出すか。ここでは8が抜き出される

#split => マッチした文字列を区切り文字にして分解し、配列に入れる
text = '123,456-789'
#文字列で区切り文字を指定
text.split(',')

#gsub => 第一引数の正規表現にマッチした文字列を第二引数の文字列で置き換える
text = '123,456-789'

text.gsub(/,|-/, ':') 

#キャプチャ => ()を使って　2000-9-28 を 2019年9月28日　に変換する鉄板パターン
text = '誕生日は2000年9月28日です'
text.gsub(/(\d+)年(\d+)月(\d+)日/, '\1-\2-\3')
# \1 \2 \3 で連番を参照している

# 名前付きキャプチャは \k<name> で参照できる

text = '誕生日は2000年9月28日です'
text.gsub(
	/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/,
	
	'\k<year>-\k<month>-\k<day>'
	)
#呼び出し部は \kのところ

#逆パ
text = '誕生日は2000-9-28です'
text.gsub(
	/(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/,
	
	'\k<year>年\k<month>月\k<day>日'
	)

#第二引数にハッシュを渡して変換のルール指定

text = '123,456-789'
#カンマ => コロン　ハイフン　=> スラッシュ
hash = { ',' => ':', '-' => '/' }
text.gsub(/,|-/, hash)
# | はOR条件を作る

